{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MPU-9250 Driver for TI-RTOS","text":"<p>A comprehensive, easy-to-use I2C driver for the MPU-9250 IMU, specifically tailored for the TI-RTOS environment on the MSP-EXP432E401Y platform. This library offers multiple levels of abstraction to get you up and running quickly.</p> <p>This library provides everything you need to go from raw sensor readings to a fully calibrated, high-performance orientation solution.</p>"},{"location":"#features","title":"Features","text":"<p>-Multi-Level API: Choose the abstraction level that fits your needs:</p> <ul> <li>A simple C library for direct register access and raw data.</li> <li>A high-level C++ class that encapsulates the complex InvenSense DMP.</li> <li>A C-compatible wrapper for using the DMP from any C project.</li> </ul> <p>-Sensor Fusion Options: Includes a lightweight Complementary Filter and a full implementation of the onboard Digital Motion Processor (DMP) for 6-axis quaternion output.</p> <p>-TI-RTOS Integration: Designed from the ground up for a real-time, task-based environment, using TI Drivers for I2C and TI-RTOS primitives for timing.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The core DMP driver is based on the work by InvenSense/TDK.</p> <p>The C++ wrapper is an adaptation of the excellent SparkFun MPU-9250 DMP Arduino Library.</p>"},{"location":"api/c_library/","title":"MPU9250 IMU Sensor Driver API Reference","text":""},{"location":"api/c_library/#1-overview","title":"1. Overview","text":"<p>This document provides the API reference for the MPU9250 IMU sensor driver. The library is designed to run on an MSP-EXP432E401Y development board within the TI-RTOS environment. It facilitates communication with the MPU9250 via I2C, providing functions for initialization, configuration, data acquisition, and processing.</p> <p>Hardware Dependencies:</p> <ul> <li>An I2C peripheral for communication.</li> <li>A GPIO pin to control the power supply to the MPU9250.</li> </ul> <p>Software Dependencies:</p> <ul> <li>TI-RTOS Kernel (<code>Task</code>, <code>System</code>)</li> <li>TI Drivers (<code>I2C</code>, <code>GPIO</code>)</li> </ul>"},{"location":"api/c_library/#2-data-structures","title":"2. Data Structures","text":"<p>The library defines several structures to organize sensor data.</p>"},{"location":"api/c_library/#vector3d","title":"<code>Vector3D</code>","text":"<p>Represents a 3-dimensional vector, used for accelerometer and gyroscope data.</p> <pre><code>typedef struct Vector3D {\n    float x;    // X-component\n    float y;    // Y-component\n    float z;    // Z-component\n} Vector3D;\n</code></pre> <ul> <li>Members:</li> <li><code>x</code>: <code>float</code> - The value on the X-axis.</li> <li><code>y</code>: <code>float</code> - The value on the Y-axis.</li> <li><code>z</code>: <code>float</code> - The value on the Z-axis.</li> </ul>"},{"location":"api/c_library/#eulerangles","title":"<code>EulerAngles</code>","text":"<p>Represents the orientation of the sensor in terms of roll, pitch, and yaw.</p> <pre><code>typedef struct EulerAngles {\n    float pitch;    // Rotation around the Y-axis\n    float roll;     // Rotation around the X-axis\n    float yaw;      // Rotation around the Z-axis\n} EulerAngles;\n</code></pre> <ul> <li>Members:</li> <li><code>pitch</code>: <code>float</code> - The pitch angle in degrees.</li> <li><code>roll</code>: <code>float</code> - The roll angle in degrees.</li> <li><code>yaw</code>: <code>float</code> - The yaw angle in degrees.</li> </ul>"},{"location":"api/c_library/#imudata","title":"<code>IMUData</code>","text":"<p>A container structure that holds all processed data from the IMU.</p> <pre><code>typedef struct IMUData {\n    Vector3D accelerometer; // Acceleration vector in m/s^2\n    Vector3D gyroscope;     // Angular velocity vector in rad/s\n    float temperature;      // Temperature reading in Celsius\n} IMUData;\n</code></pre> <ul> <li>Members:</li> <li><code>accelerometer</code>: <code>Vector3D</code> - Stores the acceleration data in m/s\u00b2.</li> <li><code>gyroscope</code>: <code>Vector3D</code> - Stores the angular velocity data in rad/s.</li> <li><code>temperature</code>: <code>float</code> - Stores the sensor's internal temperature in degrees Celsius.</li> </ul>"},{"location":"api/c_library/#3-constants-and-macros","title":"3. Constants and Macros","text":""},{"location":"api/c_library/#device-and-communication","title":"Device and Communication","text":"<ul> <li><code>MPU9250_I2C_ADDR</code>: <code>0x68</code> - The I2C slave address of the MPU9250.</li> <li><code>MPU9250_WHO_AM_I</code>: <code>0x70</code> - The expected value of the WHO_AM_I register (for MPU-9250, this can also be <code>0x71</code> or <code>0x73</code> depending on the version, but the code expects <code>0x70</code>).</li> </ul>"},{"location":"api/c_library/#physical-constants","title":"Physical Constants","text":"<ul> <li><code>G_MPS2</code>: <code>9.80665f</code> - Standard gravity in meters per second squared.</li> <li><code>RAD_TO_DEG</code>: <code>57.2957795f</code> - Conversion factor from radians to degrees.</li> <li><code>DEG_TO_RAD</code>: <code>1.0f / RAD_TO_DEG</code> - Conversion factor from degrees to radians.</li> </ul>"},{"location":"api/c_library/#register-map","title":"Register Map","text":"<p>The header file <code>MPU9250.h</code> contains a complete list of register address macros from <code>0x00</code> to <code>0x7E</code>. Key registers used in the driver include:</p> <ul> <li><code>MPU9250_CONFIG_ADDR</code>: <code>0x1A</code></li> <li><code>MPU9250_GYRO_CONFIG_ADDR</code>: <code>0x1B</code></li> <li><code>MPU9250_ACCEL_CONFIG_ADDR</code>: <code>0x1C</code></li> <li><code>MPU9250_ACCEL_CONFIG_2_ADDR</code>: <code>0x1D</code></li> <li><code>MPU9250_ACCEL_XOUT_H_ADDR</code>: <code>0x3B</code> (Start of sensor data block)</li> <li><code>MPU9250_PWR_MGMT_1_ADDR</code>: <code>0x6B</code></li> <li><code>MPU9250_WHO_AM_I_ADDR</code>: <code>0x75</code></li> </ul>"},{"location":"api/c_library/#4-function-reference","title":"4. Function Reference","text":""},{"location":"api/c_library/#power-and-reset-functions","title":"Power and Reset Functions","text":""},{"location":"api/c_library/#pwrimu","title":"<code>PWRIMU</code>","text":"<p>Controls the power supply to the MPU9250 via a GPIO pin.</p> <pre><code>void PWRIMU(bool pwr);\n</code></pre> <ul> <li>Description: Sets the state of the <code>PWR_MPU9250</code> GPIO pin. This function is intended to be connected to the VDD input of the sensor.</li> <li>Parameters:</li> <li><code>pwr</code> [in]: <code>bool</code> - The desired power state. <code>true</code> for ON, <code>false</code> for OFF.</li> </ul>"},{"location":"api/c_library/#rstimu","title":"<code>RSTIMU</code>","text":"<p>Performs a hardware reset of the MPU9250 by power cycling it.</p> <pre><code>void RSTIMU(void);\n</code></pre> <ul> <li>Description: This function calls <code>PWRIMU(false)</code> followed by <code>PWRIMU(true)</code> to cycle the power to the sensor, effectively resetting it. It also prints a reset message to the system console.</li> </ul>"},{"location":"api/c_library/#core-functions","title":"Core Functions","text":""},{"location":"api/c_library/#mpu9250_init","title":"<code>MPU9250_init</code>","text":"<p>Initializes the MPU9250 sensor with a predefined configuration.</p> <pre><code>void MPU9250_init(I2C_Handle i2c, I2C_Transaction *i2cTransaction, IMUData *IMU_Handle);\n</code></pre> <ul> <li>Description: This is the primary initialization function. It performs the following sequence:</li> <li>Resets the <code>IMU_Handle</code> data structure to zero.</li> <li>Performs a hardware reset using <code>RSTIMU()</code>.</li> <li>Performs a software reset and selects the best available clock source.</li> <li>Verifies the device identity by reading the <code>WHO_AM_I</code> register.</li> <li>Configures the gyroscope range to <code>\u00b1500 dps</code>.</li> <li>Configures the accelerometer range to <code>\u00b12g</code>.</li> <li>Sets the Digital Low-Pass Filter (DLPF) for both accelerometer and gyroscope.</li> <li>Enables the FIFO for sensor data.</li> <li>Parameters:</li> <li><code>i2c</code> [in]: <code>I2C_Handle</code> - The handle to the configured I2C peripheral.</li> <li><code>i2cTransaction</code> [in, out]: <code>I2C_Transaction *</code> - A pointer to an I2C transaction structure used for all I2C communications.</li> <li><code>IMU_Handle</code> [out]: <code>IMUData *</code> - A pointer to the main IMU data structure to be cleared.</li> <li>Note: The system will halt execution (<code>while(1);</code>) if the <code>WHO_AM_I</code> check fails or if any I2C transfer results in an error.</li> </ul>"},{"location":"api/c_library/#i2c-communication-functions","title":"I2C Communication Functions","text":""},{"location":"api/c_library/#mpu9250_writereg","title":"<code>MPU9250_writeReg</code>","text":"<p>Writes a single byte to a specified register.</p> <pre><code>void MPU9250_writeReg(I2C_Handle i2c, I2C_Transaction *i2cTransaction, uint8_t reg_addr, uint8_t dataTx);\n</code></pre> <ul> <li>Parameters:</li> <li><code>i2c</code> [in]: <code>I2C_Handle</code> - The handle to the I2C peripheral.</li> <li><code>i2cTransaction</code> [in, out]: <code>I2C_Transaction *</code> - Pointer to the I2C transaction structure.</li> <li><code>reg_addr</code> [in]: <code>uint8_t</code> - The address of the register to write to.</li> <li><code>dataTx</code> [in]: <code>uint8_t</code> - The data byte to write.</li> <li>Note: Halts the system on I2C transfer failure.</li> </ul>"},{"location":"api/c_library/#mpu9250_readreg","title":"<code>MPU9250_readReg</code>","text":"<p>Reads a single byte from a specified register.</p> <pre><code>void MPU9250_readReg(I2C_Handle i2c, I2C_Transaction *i2cTransaction, uint8_t reg_addr, uint8_t *dataRx);\n</code></pre> <ul> <li>Parameters:</li> <li><code>i2c</code> [in]: <code>I2C_Handle</code> - The handle to the I2C peripheral.</li> <li><code>i2cTransaction</code> [in, out]: <code>I2C_Transaction *</code> - Pointer to the I2C transaction structure.</li> <li><code>reg_addr</code> [in]: <code>uint8_t</code> - The address of the register to read from.</li> <li><code>dataRx</code> [out]: <code>uint8_t *</code> - A pointer to a variable where the read data will be stored.</li> <li>Note: Halts the system on I2C transfer failure.</li> </ul>"},{"location":"api/c_library/#mpu9250_readacctempgyr","title":"<code>MPU9250_readAccTempGyr</code>","text":"<p>Reads all sensor data (accelerometer, temperature, gyroscope) in a single burst read.</p> <pre><code>void MPU9250_readAccTempGyr(I2C_Handle i2c, I2C_Transaction *i2cTransaction, uint8_t *dataRx);\n</code></pre> <ul> <li>Description: Performs a 14-byte I2C burst read starting from <code>MPU9250_ACCEL_XOUT_H_ADDR</code>. This is the most efficient way to get a complete snapshot of the sensor data.</li> <li>Parameters:</li> <li><code>i2c</code> [in]: <code>I2C_Handle</code> - The handle to the I2C peripheral.</li> <li><code>i2cTransaction</code> [in, out]: <code>I2C_Transaction *</code> - Pointer to the I2C transaction structure.</li> <li><code>dataRx</code> [out]: <code>uint8_t *</code> - A pointer to a buffer of at least 14 bytes to store the raw sensor data.</li> <li>Data Order: The data is read in the following order: <code>AX_H, AX_L, AY_H, AY_L, AZ_H, AZ_L, T_H, T_L, GX_H, GX_L, GY_H, GY_L, GZ_H, GZ_L</code>.</li> <li>Note: Halts the system on I2C transfer failure.</li> </ul>"},{"location":"api/c_library/#data-processing-functions","title":"Data Processing Functions","text":""},{"location":"api/c_library/#mpu9250_unitconversion","title":"<code>MPU9250_unitConversion</code>","text":"<p>Converts the raw 14-byte sensor data into engineering units (m/s\u00b2, \u00b0C, rad/s) and applies bias correction.</p> <pre><code>void MPU9250_unitConversion(uint8_t *raw, IMUData *IMU_Handle, Vector3D accelBias, Vector3D gyroBias);\n</code></pre> <ul> <li>Description:</li> <li>Combines the high and low bytes for each sensor axis into 16-bit signed integers.</li> <li>Subtracts the provided bias values (in LSB) from the raw accelerometer and gyroscope readings.</li> <li>Converts the corrected accelerometer values to <code>m/s\u00b2</code>.</li> <li>Converts the raw temperature value to <code>\u00baC</code>.</li> <li>Converts the corrected gyroscope values to <code>rad/s</code>.</li> <li>Parameters:</li> <li><code>raw</code> [in]: <code>uint8_t *</code> - Pointer to the 14-byte buffer of raw sensor data.</li> <li><code>IMU_Handle</code> [out]: <code>IMUData *</code> - Pointer to the structure where the converted data will be stored.</li> <li><code>accelBias</code> [in]: <code>Vector3D</code> - A structure containing the accelerometer bias offsets (in LSB) for X, Y, and Z axes.</li> <li><code>gyroBias</code> [in]: <code>Vector3D</code> - A structure containing the gyroscope bias offsets (in LSB) for X, Y, and Z axes.</li> </ul>"},{"location":"api/c_library/#mpu9250_calculateangle","title":"<code>MPU9250_calculateAngle</code>","text":"<p>Calculates roll, pitch, and yaw angles from IMU data using a complementary filter.</p> <pre><code>void MPU9250_calculateAngle(IMUData *IMU_Handle, EulerAngles *anglesDegrees, float dt, float cf_alpha, float dlpf_alpha);\n</code></pre> <ul> <li>Description: Fuses accelerometer and gyroscope data to provide a stable orientation estimate.</li> <li>Applies a digital low-pass filter to the gyroscope readings to reduce noise.</li> <li>Calculates \"long-term\" roll and pitch from the accelerometer.</li> <li>Integrates gyroscope data to get \"short-term\" changes in orientation.</li> <li>Combines these two estimates using a complementary filter for stable roll and pitch.</li> <li>Yaw is calculated by integrating the Z-axis gyroscope data only.</li> <li>Parameters:</li> <li><code>IMU_Handle</code> [in]: <code>IMUData *</code> - Pointer to the struct with the latest sensor readings.</li> <li><code>anglesDegrees</code> [in, out]: <code>EulerAngles *</code> - Pointer to the struct where the calculated angles (in degrees) will be stored. The previous values are used for integration.</li> <li><code>dt</code> [in]: <code>float</code> - The time delta in seconds since the last call (the sampling period).</li> <li><code>cf_alpha</code> [in]: <code>float</code> - The complementary filter coefficient (e.g., 0.98). A higher value trusts the gyroscope more.</li> <li><code>dlpf_alpha</code> [in]: <code>float</code> - The digital low-pass filter coefficient for the gyroscope. A smaller value provides more smoothing.</li> <li>Note: The yaw angle is not corrected by an absolute reference (like a magnetometer) and will drift over time.</li> </ul>"},{"location":"api/cpp_class/","title":"MPU6500/9250 DMP Driver API Reference","text":"<p>This document provides an API reference for the <code>MPU_DMP</code> driver, which interfaces with the InvenSense MPU6500/9250 sensors and their embedded Digital Motion Processor (DMP). The library is written in C++ and includes a C-compatible wrapper for use in C projects.</p>"},{"location":"api/cpp_class/#c-api-mpu_dmp-class","title":"C++ API (<code>MPU_DMP</code> Class)","text":"<p>This is the object-oriented interface for C++ applications.</p>"},{"location":"api/cpp_class/#public-data-members","title":"Public Data Members","text":"<p>Once <code>dmpUpdateFifo()</code> is called, the following public members are updated with the latest sensor data.</p> Member Type Description <code>ax</code>,<code>ay</code>,<code>az</code> <code>int</code> Raw accelerometer data for X, Y, and Z axes. <code>gx</code>,<code>gy</code>,<code>gz</code> <code>int</code> Raw gyroscope data for X, Y, and Z axes. <code>qw</code>,<code>qx</code>,<code>qy</code>,<code>qz</code> <code>long</code> Raw quaternion data (W, X, Y, Z) in Q30 format from the DMP. <code>temperature</code> <code>long</code> Raw temperature data from the sensor. <code>time</code> <code>unsigned long</code> Timestamp for the last sensor data update (from DMP). <code>pitch</code>,<code>roll</code>,<code>yaw</code> <code>float</code> Calculated Euler angles. Updated by calling <code>computeEulerAngles()</code>. <code>mx</code>,<code>my</code>,<code>mz</code> <code>int</code> (MPU9250 only)Raw magnetometer data for X, Y, and Z axes. <code>heading</code> <code>float</code> (MPU9250 only)Calculated compass heading. Updated by <code>computeCompassHeading()</code>."},{"location":"api/cpp_class/#constructor","title":"Constructor","text":"<p><code>MPU_DMP()</code> :   Constructs a new <code>MPU_DMP</code> object.</p>"},{"location":"api/cpp_class/#basic-communication-initialization","title":"Basic Communication &amp; Initialization","text":"<p><code>int begin()</code> :   Initializes the MPU sensor and the underlying driver.</p> <ul> <li>Returns: <code>INV_SUCCESS</code> (0) on success, <code>INV_ERROR</code> (-1) on failure.</li> </ul> <p><code>int selfTest()</code> :   Runs the built-in self-test routine.</p> <ul> <li>Returns: A bitmask of test results. For MPU6500, a value of <code>0x03</code> means all sensors passed. For MPU9250, <code>0x07</code> means all passed.</li> </ul>"},{"location":"api/cpp_class/#sensor-configuration","title":"Sensor Configuration","text":"<p><code>int setSensors(unsigned char sensors)</code> :   Enables or disables specific sensors using a bitmask (e.g., <code>INV_XYZ_GYRO | INV_XYZ_ACCEL</code>).</p> <p><code>int setGyroFSR(unsigned short fsr)</code> :   Sets the gyroscope's full-scale range (dps). Valid values: 250, 500, 1000, 2000.</p> <p><code>int setAccelFSR(unsigned char fsr)</code> :   Sets the accelerometer's full-scale range (g's). Valid values: 2, 4, 8, 16.</p> <p><code>int setLPF(unsigned short lpf)</code> :   Sets the digital low-pass filter cutoff frequency (Hz). Valid values: 5, 10, 20, 42, 98, 188.</p> <p><code>int setSampleRate(unsigned short rate)</code> :   Sets the sensor sample rate in Hz.</p> <p><code>unsigned short getGyroFSR()</code> :   Gets the current gyroscope full-scale range.</p> <p><code>unsigned char getAccelFSR()</code> :   Gets the current accelerometer full-scale range.</p> <p><code>unsigned short getLPF()</code> :   Gets the current low-pass filter frequency.</p> <p><code>unsigned short getSampleRate()</code> :   Gets the current sample rate.</p> <p><code>float getGyroSens()</code> :   Gets the gyroscope's sensitivity (conversion factor from raw value to dps).</p> <p><code>unsigned short getAccelSens()</code> :   Gets the accelerometer's sensitivity (conversion factor from raw value to g's).</p> <p><code>int setCompassSampleRate(unsigned short rate)</code> :   (MPU9250 only) Sets the magnetometer sample rate in Hz.</p> <p><code>unsigned short getCompassSampleRate()</code> :   (MPU9250 only) Gets the magnetometer sample rate.</p>"},{"location":"api/cpp_class/#dmp-digital-motion-processor-functions","title":"DMP (Digital Motion Processor) Functions","text":"<p><code>int dmpBegin(unsigned short features, unsigned short fifoRate = 100)</code> :   Loads the DMP firmware and configures its features.</p> <ul> <li>features: A bitmask of DMP features to enable (e.g., DMP_FEATURE_6X_LP_QUAT).</li> <li>fifoRate: The desired rate in Hz for the DMP to update the FIFO buffer.</li> <li>Returns: INV_SUCCESS on success.</li> </ul> <p><code>int dmpUpdateFifo()</code> :   Reads the latest data packet from the DMP FIFO and updates the public data members. This should be called frequently.</p> <ul> <li>Returns: INV_SUCCESS if a new packet was read.</li> </ul> <p><code>int dmpSetFifoRate(unsigned short rate)</code> :   Sets the DMP FIFO update rate in Hz.</p> <p><code>unsigned short dmpGetFifoRate()</code> :   Gets the current DMP FIFO update rate.</p> <p><code>unsigned long dmpGetPedometerSteps()</code> :   Gets the total steps counted by the DMP's pedometer.</p> <p><code>int dmpSetPedometerSteps(unsigned long steps)</code> :   Sets the pedometer's internal step counter.</p> <p><code>int dmpSetTap(unsigned short xThresh, unsigned short yThresh, unsigned short zThresh, unsigned char taps)</code> :   Configures the DMP's tap detection feature.</p> <p><code>bool tapAvailable()</code> :   Checks if a new tap has been detected.</p> <p><code>unsigned char getTapDir()</code> :   Gets the direction and axis of the last detected tap.</p> <p><code>unsigned char getTapCount()</code> :   Gets the count of the last detected tap event.</p> <p><code>int dmpSetOrientation(const signed char *orientationMatrix)</code> :   Sets the DMP's orientation matrix.</p> <p><code>unsigned char dmpGetOrientation()</code> :   Gets the orientation result from the DMP's Android-style orientation feature.</p>"},{"location":"api/cpp_class/#data-conversion-calculation","title":"Data Conversion &amp; Calculation","text":"<p><code>float calcAccel(int axis_val)</code> :   Converts a raw accelerometer value to g's.</p> <p><code>float calcGyro(int axis_val)</code> :   Converts a raw gyroscope value to degrees per second.</p> <p><code>float calcQuat(long quat_val)</code> :   Converts a raw Q30 format quaternion value to a floating-point number.</p> <p><code>void computeEulerAngles(bool degrees = true)</code> :   Computes pitch, roll, and yaw from the current quaternion data, updating the public members.</p> <p><code>float calcMag(int axis_val)</code> :   (MPU9250 only) Converts a raw magnetometer value to microteslas (uT).</p> <p><code>float computeCompassHeading()</code> :   (MPU9250 only) Computes the compass heading from raw magnetometer data.</p>"},{"location":"api/cpp_class/#c-compatible-api-mpu_dmp_ch","title":"C-Compatible API (<code>MPU_DMP_C.h</code>)","text":"<p>This is a procedural wrapper around the C++ class for use in C projects.</p>"},{"location":"api/cpp_class/#handle-management","title":"Handle Management","text":"<p>All C functions operate on an opaque pointer, <code>MPU_DMP_Handle</code>.</p> <p><code>MPU_DMP_Handle MPU_DMP_Create()</code> :   Creates a new MPU_DMP instance and returns a handle to it.</p> <p><code>void MPU_DMP_Destroy(MPU_DMP_Handle handle)</code> :   Destroys an MPU_DMP instance and frees its memory.</p>"},{"location":"api/cpp_class/#function-reference","title":"Function Reference","text":"<p>The C API provides functions that directly correspond to the methods in the C++ class. The C++ object's methods are mapped to C functions by replacing <code>object.method(args)</code> with <code>MPU_DMP_method(handle, args)</code>.</p> <p>Example:</p> <ul> <li>C++: <code>myMpu.begin()</code> becomes C: <code>MPU_DMP_begin(myMpuHandle)</code></li> <li>C++: <code>myMpu.setGyroFSR(2000)</code> becomes C: <code>MPU_DMP_setGyroFSR(myMpuHandle, 2000)</code></li> </ul> <p>Data Access:</p> <p>Since C cannot directly access the C++ object's public members, getter functions are provided for all public data members.</p> <p>Example:</p> <ul> <li>To get the raw accelerometer X value: <code>int ax = MPU_DMP_get_ax(myMpuHandle);</code></li> <li>To get the calculated pitch: <code>float pitch = MPU_DMP_get_pitch(myMpuHandle);</code></li> </ul> <p>Please refer to the <code>MPU_DMP_C.h</code> header for a complete list of all C functions, as they are a direct mapping of the C++ methods and data getters described above.</p>"}]}